'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./debug'),
    debug = _require.debug,
    setDebugNamespace = _require.setDebugNamespace,
    getDebug = _require.getDebug;

var isUrlMatcher = function isUrlMatcher(matcher) {
	return matcher instanceof RegExp || typeof matcher === 'string' || (typeof matcher === 'undefined' ? 'undefined' : (0, _typeof3.default)(matcher)) === 'object' && 'href' in matcher;
};

var isFunctionMatcher = function isFunctionMatcher(matcher) {
	return typeof matcher === 'function';
};

var argsToRoute = function argsToRoute(args) {
	var _args = (0, _slicedToArray3.default)(args, 3),
	    matcher = _args[0],
	    response = _args[1],
	    _args$ = _args[2],
	    options = _args$ === undefined ? {} : _args$;

	var routeConfig = {};

	if (isUrlMatcher(matcher) || isFunctionMatcher(matcher)) {
		routeConfig.matcher = matcher;
	} else {
		(0, _assign2.default)(routeConfig, matcher);
	}

	if (typeof response !== 'undefined') {
		routeConfig.response = response;
	}

	(0, _assign2.default)(routeConfig, options);
	return routeConfig;
};

var sanitizeRoute = function sanitizeRoute(route) {
	var debug = getDebug('sanitizeRoute()');
	debug('Sanitizing route properties');
	route = (0, _assign2.default)({}, route);

	if (route.method) {
		debug('Converting method ' + route.method + ' to lower case');
		route.method = route.method.toLowerCase();
	}
	if (isUrlMatcher(route.matcher)) {
		debug('Mock uses a url matcher', route.matcher);
		route.url = route.matcher;
		delete route.matcher;
	}

	route.functionMatcher = route.matcher || route.functionMatcher;

	debug('Setting route.identifier...');
	debug('  route.name is ' + route.name);
	debug('  route.url is ' + route.url);
	debug('  route.functionMatcher is ' + route.functionMatcher);
	route.identifier = route.name || route.url || route.functionMatcher;
	debug('  -> route.identifier set to ' + route.identifier);
	return route;
};

var validateRoute = function validateRoute(route) {
	if (!('response' in route)) {
		throw new Error('fetch-mock: Each route must define a response');
	}

	if (!this._matchers.some(function (_ref) {
		var name = _ref.name;
		return name in route;
	})) {
		throw new Error("fetch-mock: Each route must specify some criteria for matching calls to fetch. To match all calls use '*'");
	}
};

var limit = function limit(route) {
	var debug = getDebug('limit()');
	debug('Limiting number of requests to handle by route');
	if (!route.repeat) {
		debug('  No `repeat` value set on route. Will match any number of requests');
		return;
	}

	debug('  Route set to repeat ' + route.repeat + ' times');
	var matcher = route.matcher;
	var timesLeft = route.repeat;
	route.matcher = function (url, options) {
		var match = timesLeft && matcher(url, options);
		if (match) {
			timesLeft--;
			return true;
		}
	};
	route.reset = function () {
		return timesLeft = route.repeat;
	};
};

var delayResponse = function delayResponse(route) {
	var debug = getDebug('delayResponse()');
	debug('Applying response delay settings');
	var delay = route.delay;

	if (delay) {
		debug('  Wrapping response in delay of ' + delay + ' miliseconds');
		var response = route.response;
		route.response = function () {
			debug('Delaying response by ' + delay + ' miliseconds');
			return new _promise2.default(function (res) {
				return setTimeout(function () {
					return res(response);
				}, delay);
			});
		};
	} else {
		debug('  No delay set on route. Will respond \'immediately\' (but asynchronously)');
	}
};

var generateMatcher = function generateMatcher(route) {
	var _this = this;

	setDebugNamespace('generateMatcher()');
	debug('Compiling matcher for route');

	var matchers = this._matchers.map(function (_ref2) {
		var name = _ref2.name,
		    matcher = _ref2.matcher,
		    usesBody = _ref2.usesBody;
		return route[name] && { matcher: matcher(route, _this), usesBody: usesBody };
	}).filter(function (matcher) {
		return Boolean(matcher);
	});

	route.usesBody = matchers.some(function (_ref3) {
		var usesBody = _ref3.usesBody;
		return usesBody;
	});

	debug('Compiled matcher for route');
	setDebugNamespace();
	return function (url) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var request = arguments[2];
		return matchers.every(function (_ref4) {
			var matcher = _ref4.matcher;
			return matcher(url, options, request);
		});
	};
};

var compileRoute = function compileRoute(args) {
	var debug = getDebug('compileRoute()');
	debug('Compiling route');
	var route = sanitizeRoute(argsToRoute(args));
	this.validateRoute(route);
	route.matcher = this.generateMatcher(route);
	limit(route);
	delayResponse(route);
	return route;
};

module.exports = {
	compileRoute: compileRoute,
	sanitizeRoute: sanitizeRoute,
	generateMatcher: generateMatcher,
	validateRoute: validateRoute
};
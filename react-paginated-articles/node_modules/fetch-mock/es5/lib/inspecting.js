'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./debug'),
    setDebugPhase = _require.setDebugPhase,
    setDebugNamespace = _require.setDebugNamespace,
    debug = _require.debug;

var _require2 = require('./request-utils'),
    normalizeUrl = _require2.normalizeUrl;

var FetchMock = {};
var isName = function isName(nameOrMatcher) {
	return typeof nameOrMatcher === 'string' && /^[\da-zA-Z\-]+$/.test(nameOrMatcher);
};

var filterCallsWithMatcher = function filterCallsWithMatcher(matcher) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var calls = arguments[2];

	matcher = this.generateMatcher(this.sanitizeRoute((0, _assign2.default)({ matcher: matcher }, options)));
	return calls.filter(function (_ref) {
		var url = _ref.url,
		    options = _ref.options;
		return matcher(normalizeUrl(url), options);
	});
};

var formatDebug = function formatDebug(func) {
	return function () {
		setDebugPhase('inspect');

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		var result = func.call.apply(func, [this].concat(args));
		setDebugPhase();
		return result;
	};
};

var callObjToArray = function callObjToArray(obj) {
	if (!obj) {
		return undefined;
	}
	var url = obj.url,
	    options = obj.options,
	    request = obj.request,
	    identifier = obj.identifier,
	    isUnmatched = obj.isUnmatched,
	    response = obj.response;

	var arr = [url, options];
	arr.request = request;
	arr.identifier = identifier;
	arr.isUnmatched = isUnmatched;
	arr.response = response;
	return arr;
};

FetchMock.filterCalls = function (nameOrMatcher, options) {
	debug('Filtering fetch calls');
	var calls = this._calls;
	var matcher = '*';

	if ([true, 'matched'].includes(nameOrMatcher)) {
		debug('Filter provided is ' + nameOrMatcher + '. Returning matched calls only');
		calls = calls.filter(function (_ref2) {
			var isUnmatched = _ref2.isUnmatched;
			return !isUnmatched;
		});
	} else if ([false, 'unmatched'].includes(nameOrMatcher)) {
		debug('Filter provided is ' + nameOrMatcher + '. Returning unmatched calls only');
		calls = calls.filter(function (_ref3) {
			var isUnmatched = _ref3.isUnmatched;
			return isUnmatched;
		});
	} else if (typeof nameOrMatcher === 'undefined') {
		debug('Filter provided is undefined. Returning all calls');
		calls = calls;
	} else if (isName(nameOrMatcher)) {
		debug('Filter provided, looks like the name of a named route. Returning only calls handled by that route');
		calls = calls.filter(function (_ref4) {
			var identifier = _ref4.identifier;
			return identifier === nameOrMatcher;
		});
	} else {
		matcher = nameOrMatcher === '*' ? '*' : normalizeUrl(nameOrMatcher);
		if (this.routes.some(function (_ref5) {
			var identifier = _ref5.identifier;
			return identifier === matcher;
		})) {
			debug('Filter provided, ' + nameOrMatcher + ', identifies a route. Returning only calls handled by that route');
			calls = calls.filter(function (call) {
				return call.identifier === matcher;
			});
		}
	}

	if ((options || matcher !== '*') && calls.length) {
		if (typeof options === 'string') {
			options = { method: options };
		}
		debug('Compiling filter and options to route in order to filter all calls', nameOrMatcher);
		calls = filterCallsWithMatcher.call(this, matcher, options, calls);
	}
	debug('Retrieved ' + calls.length + ' calls');
	return calls.map(callObjToArray);
};

FetchMock.calls = formatDebug(function (nameOrMatcher, options) {
	debug('retrieving matching calls');
	return this.filterCalls(nameOrMatcher, options);
});

FetchMock.lastCall = formatDebug(function (nameOrMatcher, options) {
	debug('retrieving last matching call');
	return [].concat((0, _toConsumableArray3.default)(this.filterCalls(nameOrMatcher, options))).pop();
});

FetchMock.lastUrl = formatDebug(function (nameOrMatcher, options) {
	debug('retrieving url of last matching call');
	return (this.lastCall(nameOrMatcher, options) || [])[0];
});

FetchMock.lastOptions = formatDebug(function (nameOrMatcher, options) {
	debug('retrieving options of last matching call');
	return (this.lastCall(nameOrMatcher, options) || [])[1];
});

FetchMock.lastResponse = formatDebug(function (nameOrMatcher, options) {
	debug('retrieving respose of last matching call');
	console.warn('When doing all the following:\n- using node-fetch\n- responding with a real network response (using spy() or fallbackToNetwork)\n- using `fetchMock.LastResponse()`\n- awaiting the body content\n... the response will hang unless your source code also awaits the response body.\nThis is an unavoidable consequence of the nodejs implementation of streams.\n');
	var response = (this.lastCall(nameOrMatcher, options) || []).response;
	try {
		var clonedResponse = response.clone();
		return clonedResponse;
	} catch (err) {
		(0, _entries2.default)(response._fmResults).forEach(function (_ref6) {
			var _ref7 = (0, _slicedToArray3.default)(_ref6, 2),
			    name = _ref7[0],
			    result = _ref7[1];

			response[name] = function () {
				return result;
			};
		});
		return response;
	}
});

FetchMock.called = formatDebug(function (nameOrMatcher, options) {
	debug('checking if matching call was made');
	return Boolean(this.filterCalls(nameOrMatcher, options).length);
});

FetchMock.flush = formatDebug(function () {
	var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(waitForResponseMethods) {
		var queuedPromises;
		return _regenerator2.default.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						setDebugNamespace('flush');
						debug('flushing all fetch calls. ' + (waitForResponseMethods ? '' : 'Not ') + 'waiting for response bodies to complete download');

						queuedPromises = this._holdingPromises;

						this._holdingPromises = [];
						debug(queuedPromises.length + ' fetch calls to be awaited');

						_context.next = 7;
						return _promise2.default.all(queuedPromises);

					case 7:
						debug('All fetch calls have completed');

						if (!(waitForResponseMethods && this._holdingPromises.length)) {
							_context.next = 13;
							break;
						}

						debug('Awaiting all fetch bodies to download');
						_context.next = 12;
						return this.flush(waitForResponseMethods);

					case 12:
						debug('All fetch bodies have completed downloading');

					case 13:
						setDebugNamespace();

					case 14:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, this);
	}));

	return function (_x2) {
		return _ref8.apply(this, arguments);
	};
}());

FetchMock.done = formatDebug(function (nameOrMatcher) {
	var _this = this;

	setDebugPhase('inspect');
	setDebugNamespace('done');
	debug('Checking to see if expected calls have been made');
	var routesToCheck = void 0;

	if (nameOrMatcher && typeof nameOrMatcher !== 'boolean') {
		debug('Checking to see if expected calls have been made for single route:', nameOrMatcher);
		routesToCheck = [{ identifier: nameOrMatcher }];
	} else {
		debug('Checking to see if expected calls have been made for all routes');
		routesToCheck = this.routes;
	}

	// Can't use array.every because would exit after first failure, which would
	// break the logging
	var result = routesToCheck.map(function (_ref9) {
		var identifier = _ref9.identifier;

		if (!_this.called(identifier)) {
			debug('No calls made for route:', identifier);
			console.warn('Warning: ' + identifier + ' not called'); // eslint-disable-line
			return false;
		}

		var expectedTimes = (_this.routes.find(function (r) {
			return r.identifier === identifier;
		}) || {}).repeat;

		if (!expectedTimes) {
			debug('Route has been called at least once, and no expectation of more set:', identifier);
			return true;
		}
		var actualTimes = _this.filterCalls(identifier).length;

		debug('Route called ' + actualTimes + ' times:', identifier);
		if (expectedTimes > actualTimes) {
			debug('Route called ' + actualTimes + ' times, but expected ' + expectedTimes + ':', identifier);
			console.warn('Warning: ' + identifier + ' only called ' + actualTimes + ' times, but ' + expectedTimes + ' expected'); // eslint-disable-line
			return false;
		} else {
			return true;
		}
	}).every(function (isDone) {
		return isDone;
	});

	setDebugNamespace();
	setDebugPhase();
	return result;
});

module.exports = FetchMock;
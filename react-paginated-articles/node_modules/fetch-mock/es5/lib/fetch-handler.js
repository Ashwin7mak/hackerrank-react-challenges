'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./debug'),
    debug = _require.debug,
    setDebugPhase = _require.setDebugPhase,
    getDebug = _require.getDebug;

var responseBuilder = require('./response-builder');
var requestUtils = require('./request-utils');
var FetchMock = {};

// see https://heycam.github.io/webidl/#aborterror for the standardised interface
// Note that this differs slightly from node-fetch

var AbortError = function (_Error) {
	(0, _inherits3.default)(AbortError, _Error);

	function AbortError() {
		(0, _classCallCheck3.default)(this, AbortError);

		var _this = (0, _possibleConstructorReturn3.default)(this, (AbortError.__proto__ || (0, _getPrototypeOf2.default)(AbortError)).apply(this, arguments));

		_this.name = 'AbortError';
		_this.message = 'The operation was aborted.';

		// Do not include this class in the stacktrace
		if (Error.captureStackTrace) {
			Error.captureStackTrace(_this, _this.constructor);
		}
		return _this;
	}

	return AbortError;
}(Error);

// Patch native fetch to avoid "NotSupportedError:ReadableStream uploading is not supported" in Safari.
// See also https://github.com/wheresrhys/fetch-mock/issues/584
// See also https://stackoverflow.com/a/50952018/1273406


var patchNativeFetchForSafari = function patchNativeFetchForSafari(nativeFetch) {
	// Try to patch fetch only on Safari
	if (typeof navigator === 'undefined' || !navigator.vendor || navigator.vendor !== 'Apple Computer, Inc.') {
		return nativeFetch;
	}
	// It seems the code is working on Safari thus patch native fetch to avoid the error.
	return function () {
		var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(request) {
			var method, body, cache, credentials, headers, integrity, mode, redirect, referrer, init;
			return _regenerator2.default.wrap(function _callee$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							method = request.method;

							if (['POST', 'PUT', 'PATCH'].includes(method)) {
								_context.next = 3;
								break;
							}

							return _context.abrupt('return', nativeFetch(request));

						case 3:
							_context.next = 5;
							return request.clone().text();

						case 5:
							body = _context.sent;
							cache = request.cache, credentials = request.credentials, headers = request.headers, integrity = request.integrity, mode = request.mode, redirect = request.redirect, referrer = request.referrer;
							init = {
								body: body,
								cache: cache,
								credentials: credentials,
								headers: headers,
								integrity: integrity,
								mode: mode,
								redirect: redirect,
								referrer: referrer,
								method: method
							};
							return _context.abrupt('return', nativeFetch(request.url, init));

						case 9:
						case 'end':
							return _context.stop();
					}
				}
			}, _callee, undefined);
		}));

		return function (_x) {
			return _ref.apply(this, arguments);
		};
	}();
};

var resolve = function () {
	var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_ref2, url, options, request) {
		var response = _ref2.response,
		    _ref2$responseIsFetch = _ref2.responseIsFetch,
		    responseIsFetch = _ref2$responseIsFetch === undefined ? false : _ref2$responseIsFetch;
		var debug;
		return _regenerator2.default.wrap(function _callee2$(_context2) {
			while (1) {
				switch (_context2.prev = _context2.next) {
					case 0:
						debug = getDebug('resolve()');

						debug('Recursively resolving function and promise responses');
						// We want to allow things like
						// - function returning a Promise for a response
						// - delaying (using a timeout Promise) a function's execution to generate
						//   a response
						// Because of this we can't safely check for function before Promisey-ness,
						// or vice versa. So to keep it DRY, and flexible, we keep trying until we
						// have something that looks like neither Promise nor function

					case 2:
						if (!true) {
							_context2.next = 30;
							break;
						}

						if (!(typeof response === 'function')) {
							_context2.next = 17;
							break;
						}

						debug('  Response is a function');
						// in the case of falling back to the network we need to make sure we're using
						// the original Request instance, not our normalised url + options

						if (!responseIsFetch) {
							_context2.next = 13;
							break;
						}

						if (!request) {
							_context2.next = 9;
							break;
						}

						debug('  -> Calling fetch with Request instance');
						return _context2.abrupt('return', response(request));

					case 9:
						debug('  -> Calling fetch with url and options');
						return _context2.abrupt('return', response(url, options));

					case 13:
						debug('  -> Calling response function');
						response = response(url, options, request);

					case 15:
						_context2.next = 28;
						break;

					case 17:
						if (!(typeof response.then === 'function')) {
							_context2.next = 25;
							break;
						}

						debug('  Response is a promise');
						debug('  -> Resolving promise');
						_context2.next = 22;
						return response;

					case 22:
						response = _context2.sent;
						_context2.next = 28;
						break;

					case 25:
						debug('  Response is not a function or a promise');
						debug('  -> Exiting response resolution recursion');
						return _context2.abrupt('return', response);

					case 28:
						_context2.next = 2;
						break;

					case 30:
					case 'end':
						return _context2.stop();
				}
			}
		}, _callee2, undefined);
	}));

	return function resolve(_x2, _x3, _x4, _x5) {
		return _ref3.apply(this, arguments);
	};
}();

FetchMock.needsAsyncBodyExtraction = function (_ref4) {
	var request = _ref4.request;

	return request && this.routes.some(function (_ref5) {
		var usesBody = _ref5.usesBody;
		return usesBody;
	});
};

FetchMock.fetchHandler = function (url, options) {
	setDebugPhase('handle');
	var debug = getDebug('fetchHandler()');
	debug('fetch called with:', url, options);

	var normalizedRequest = requestUtils.normalizeRequest(url, options, this.config.Request);

	debug('Request normalised');
	debug('  url', normalizedRequest.url);
	debug('  options', normalizedRequest.options);
	debug('  request', normalizedRequest.request);
	debug('  signal', normalizedRequest.signal);

	if (this.needsAsyncBodyExtraction(normalizedRequest)) {
		debug('Need to wait for Body to be streamed before calling router: switching to async mode');
		return this._extractBodyThenHandle(normalizedRequest);
	}
	return this._fetchHandler(normalizedRequest);
};

FetchMock._extractBodyThenHandle = function () {
	var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(normalizedRequest) {
		return _regenerator2.default.wrap(function _callee3$(_context3) {
			while (1) {
				switch (_context3.prev = _context3.next) {
					case 0:
						_context3.next = 2;
						return normalizedRequest.options.body;

					case 2:
						normalizedRequest.options.body = _context3.sent;
						return _context3.abrupt('return', this._fetchHandler(normalizedRequest));

					case 4:
					case 'end':
						return _context3.stop();
				}
			}
		}, _callee3, this);
	}));

	return function (_x6) {
		return _ref6.apply(this, arguments);
	};
}();

FetchMock._fetchHandler = function (_ref7) {
	var _this2 = this;

	var url = _ref7.url,
	    options = _ref7.options,
	    request = _ref7.request,
	    signal = _ref7.signal;

	var _executeRouter = this.executeRouter(url, options, request),
	    route = _executeRouter.route,
	    callLog = _executeRouter.callLog;

	this.recordCall(callLog);

	// this is used to power the .flush() method
	var done = void 0;
	this._holdingPromises.push(new this.config.Promise(function (res) {
		return done = res;
	}));

	// wrapped in this promise to make sure we respect custom Promise
	// constructors defined by the user
	return new this.config.Promise(function (res, rej) {
		if (signal) {
			debug('signal exists - enabling fetch abort');
			var abort = function abort() {
				debug('aborting fetch');
				// note that DOMException is not available in node.js;
				// even node-fetch uses a custom error class:
				// https://github.com/bitinn/node-fetch/blob/master/src/abort-error.js
				rej(typeof DOMException !== 'undefined' ? new DOMException('The operation was aborted.', 'AbortError') : new AbortError());
				done();
			};
			if (signal.aborted) {
				debug('signal is already aborted - aborting the fetch');
				abort();
			}
			signal.addEventListener('abort', abort);
		}

		_this2.generateResponse({ route: route, url: url, options: options, request: request, callLog: callLog }).then(res, rej).then(done, done).then(function () {
			setDebugPhase();
		});
	});
};

FetchMock.fetchHandler.isMock = true;

FetchMock.executeRouter = function (url, options, request) {
	var debug = getDebug('executeRouter()');
	var callLog = { url: url, options: options, request: request, isUnmatched: true };
	debug('Attempting to match request to a route');
	if (this.getOption('fallbackToNetwork') === 'always') {
		debug('  Configured with fallbackToNetwork=always - passing through to fetch');
		return {
			route: { response: this.getNativeFetch(), responseIsFetch: true }
			// BUG - this callLog never used to get sent. Discovered the bug
			// but can't fix outside a major release as it will potentially
			// cause too much disruption
			//
			// callLog,
		};
	}

	var route = this.router(url, options, request);

	if (route) {
		debug('  Matching route found');
		return {
			route: route,
			callLog: {
				url: url,
				options: options,
				request: request,
				identifier: route.identifier
			}
		};
	}

	if (this.getOption('warnOnFallback')) {
		console.warn('Unmatched ' + (options && options.method || 'GET') + ' to ' + url); // eslint-disable-line
	}

	if (this.fallbackResponse) {
		debug('  No matching route found - using fallbackResponse');
		return { route: { response: this.fallbackResponse }, callLog: callLog };
	}

	if (!this.getOption('fallbackToNetwork')) {
		throw new Error('fetch-mock: No fallback response defined for ' + (options && options.method || 'GET') + ' to ' + url);
	}

	debug('  Configured to fallbackToNetwork - passing through to fetch');
	return {
		route: { response: this.getNativeFetch(), responseIsFetch: true },
		callLog: callLog
	};
};

FetchMock.generateResponse = function () {
	var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(_ref8) {
		var route = _ref8.route,
		    url = _ref8.url,
		    options = _ref8.options,
		    request = _ref8.request,
		    _ref8$callLog = _ref8.callLog,
		    callLog = _ref8$callLog === undefined ? {} : _ref8$callLog;

		var debug, response, _responseBuilder, _responseBuilder2, realResponse, finalResponse;

		return _regenerator2.default.wrap(function _callee4$(_context4) {
			while (1) {
				switch (_context4.prev = _context4.next) {
					case 0:
						debug = getDebug('generateResponse()');
						_context4.next = 3;
						return resolve(route, url, options, request);

					case 3:
						response = _context4.sent;

						if (!(response.throws && typeof response !== 'function')) {
							_context4.next = 7;
							break;
						}

						debug('response.throws is defined - throwing an error');
						throw response.throws;

					case 7:
						if (!this.config.Response.prototype.isPrototypeOf(response)) {
							_context4.next = 11;
							break;
						}

						debug('response is already a Response instance - returning it');
						callLog.response = response;
						return _context4.abrupt('return', response);

					case 11:

						// finally, if we need to convert config into a response, we do it
						_responseBuilder = responseBuilder({
							url: url,
							responseConfig: response,
							fetchMock: this,
							route: route
						}), _responseBuilder2 = (0, _slicedToArray3.default)(_responseBuilder, 2), realResponse = _responseBuilder2[0], finalResponse = _responseBuilder2[1];


						callLog.response = realResponse;

						return _context4.abrupt('return', finalResponse);

					case 14:
					case 'end':
						return _context4.stop();
				}
			}
		}, _callee4, this);
	}));

	return function (_x7) {
		return _ref9.apply(this, arguments);
	};
}();

FetchMock.router = function (url, options, request) {
	var route = this.routes.find(function (route, i) {
		debug('Trying to match route ' + i);
		return route.matcher(url, options, request);
	});

	if (route) {
		return route;
	}
};

FetchMock.getNativeFetch = function () {
	var func = this.realFetch || this.isSandbox && this.config.fetch;
	if (!func) {
		throw new Error('fetch-mock: Falling back to network only available on global fetch-mock, or by setting config.fetch on sandboxed fetch-mock');
	}
	return patchNativeFetchForSafari(func);
};

FetchMock.recordCall = function (obj) {
	debug('Recording fetch call', obj);
	if (obj) {
		this._calls.push(obj);
	}
};

module.exports = FetchMock;